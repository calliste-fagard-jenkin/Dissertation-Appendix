#### DISCLAIMER : THE VAST MAJORITY OF THE CODE IN THIS FILE WAS IMPLEMENTED 
#### FOR THE BAYES METHODS PROJECT. THE CODE WAS ADAPTED TO WORK WITH A PARTICLE
#### FILTER WHICH ESTIMATES THE LIKELIHOOD, BUT MOST OF THIS FILE SHOULD BE 
#### CONSIDERED AS WORK WHICH WAS UNDERTAKEN AS PART OF A DIFFERENT PROJECT.

library(mvtnorm)
library(parallel)
library(doParallel)
library(foreach)

################ PROPOSAL FUNCTIONS AND CORRELATION FINDING FUNCTIONS ##########

multvarNormProp <- function(xt, propPars){
  # purpose : A multivariate Gaussian random walk proposal for Met-Hastings
  #           MCMC
  # inputs  : xt       - The value of the chain at the previous time step 
  #           propPars - The correlation structure of the proposal
  return(rmvnorm(1, mean=xt, sigma=propPars))
}

multvarPropUpdate <- function(chain){
  # purpose : Updates the covariance structure of a multivariate Gaussian 
  #           random walk proposal using the sample correlation of the samples.
  # inputs  : The chain, where columns are parameters, and rows are sets of
  #           simulatenous parameter updates
  return(cov(chain[,-1]))
}

######################## IMPLEMENTATION OF THE SAMPLER #########################
MH <- function(proposal, propPars, lTarg, lTargPars, x0, itermax=1000,
               uFunc=NULL, prntPars=FALSE){
  # purpose : Adaptive Metropolis hastings MCMC
  # inputs  : proposal  - A function which generates proposals for new points
  #           propPars  - Parameters for the proposal distribution
  #           lTarg     - A function which can evaluate the log target
  #           lTargPars - The parameters of the log-target
  #           x0        - A chosen point at which to commence to algorithm
  #           itermax   - The maximum number of points to propose
  #           uFunc     - If an update function is provided, adaptive MCMC
  #                       will be used instead.
  # output  : A list of points generated by the MCMC algorithm
  n <- length(x0) + 1
  xPrev <- x0

  # if there's no update function to do adaptive MCMC, we simply run the chain
  # normally and return the result:
  if (is.null(uFunc)){
    chain <- runChain(itermax, proposal, propPars, xPrev, lTarg, lTargPars)
    return(chain)
  }
  
  # otherwise, we perform adaptive MCMC:
  else{
    output <- matrix(c(lTarg(xPrev, lTargPars), xPrev), nrow=1, byrow=T)
    
    # We perform the MCMC in three phases. An inital warmup phase (lasting 25%
    # of itermax), follOwed by an adaptation phase, where we use the warmup
    # samples to modify our proposal, sample 25% of itermax more samples and
    # then modify the proposal again. The final stage uses the newest proposal
    # to produce samples for the last 50% of itermax iterations
    
    # Split itermax into 2 groups of 25% and one group of 50%:
    div <- c(round((itermax-1)/4))
    indices <- c(div, div, itermax-2*div)
    
    for (im in indices){
      # Optionally display the proposal parameters:
      if (prntPars) print(propPars)
      
      # run the chain:
      chain <- runChain(im, proposal, propPars, xPrev, lTarg, lTargPars)
      
      # add the samples to the output matrix
      output <- rbind(output, chain)
      
      # This line simply breaks out the loop if we don't have a following 
      # phase, to avoid the computational cost of updating our parameters:
      if(dim(output)[1]>=itermax) break
      
      # update the proposal parameters for the next phase:
      propPars <- uFunc(chain)
      
      # update xPrev for the next phase:
      xPrev <- chain[im,-1]
    }
    return(output)
  }
}

pMH <- function(proposal, propPars, lTarg, lTargPars, x0, itermax=1000,
                uFunc=NULL, prntPars=FALSE, nChains=4, clNeeds, RcppFile=NULL,
                packages = "Rcpp", cores=detectCores()){
  # purpose : wrapper function which runs MCMC chains in parallel
  # inputs  : nChains   - The number of chains which should be run
  #           clNeeds   - The character names of functions which need to be 
  #                       exported to the cluster.
  #           RcppFile  - The Rcpp file which must be fourced for required
  #                       Rcpp code to work
  #           other     - for all other inputs, refer to the description given
  #                       in the MH function.
  # output  : A list containing the output matrices of all chains
  # note : loads Rcpp onto the cluster by default.
  
  # Create the clusters and initiate paralellisation:
  cl<-makeCluster(cores)
  registerDoParallel(cl)
  clusterExport(cl, c(c("MH","runChain"), clNeeds))
  
  
  # Do the parallel loop:
  ls <- foreach(i=1:nChains, .packages = packages) %dopar%{
    
    # source any required files:
    if (!is.null(RcppFile)) Rcpp::sourceCpp(RcppFile)
    
    # then run the chain on the cluster:
    to.ls <- MH(proposal = proposal, propPars = propPars, lTarg = lTarg,
                lTargPars = lTargPars, x0 = x0, itermax = itermax,
                uFunc = uFunc, prntPars = prntPars)
  }
  
  # Do the tear down for the parallelisation, we exception handle it simply
  # to silence a bunch of warnings that indicate which connections to unused
  # ports are closed by stopping the cluster
  try(stopCluster(cl), silent = T)
  class(ls) <- 'pMCMCoutput'
  return(ls)
}

runChain <- function(itermax, proposal, propPars, xPrev, lTarg, lTargPars){
  # purpose : subroutine of MH, which performs the running of the MCMC chain.
  #           Using this subroutine allows for a cleaner implementation of 
  #           adaptive metropolis hastings
  n <- length(xPrev) + 1
  output <- matrix(NA, nrow=itermax, ncol=n)
  
  # Add the initial point, the final column of the output matrix is an 
  # evaluation of the log Target at the sampled point:
  output[1, ] <- c(lTarg(xPrev, lTargPars), xPrev)
  
  t <- 2
  while (t <= itermax){

    # generate a proposed point:
    xNew <- proposal(xPrev, propPars)
    
    # calculate the acceptance probability:
    lTargNew <- try(lTarg(xNew, lTargPars), silent=T)
    
    # If the parameter set is so bad that we can't work out its probability, 
    # skip it, and decrease the index to match:
    if (class(lTargNew)=='try-error') next
    
    lTargOld <- output[t-1, 1]
    alpha <- exp(lTargNew - lTargOld)
    
    # determine acceptance or rejection:
    u <- runif(1)
    if (u<=alpha) output[t,] <- c(lTargNew, xNew)
    else output[t,] <- c(lTargOld, xPrev)
    
    # update Xt-1
    xPrev <- output[t,2:n]
    
    # update iterator:
    t <- t + 1
  }
  
  return(output)
}

############### RELATED UTILS FOR DIAGNOSTICS AND PLOTTING #####################

plot.pMCMCoutput <- function(chains, names=NULL, cols=NULL, filePath=NULL, 
                             cex=1, ...){
  # purpose : Draws diagnostic plots of an MCMC chain given the sampled points
  # input   : The output of the MCMC chain, containing the sampled points, 
  #           and the evaluation of the log target at each sampled point, and
  #           a vector of names for the pairwise plots, as well as an optional
  #           selection of columns to plot.
  # output  : returns nothing, but produces plots
  
  # define some helper functions for plotting:
  plotCol <- function(x) plot(x, type='l', col='blue', cex.lab=cex,
                              cex.axis=cex, cex.main=cex)
  plotACF <- function(x) plot(acf(x, plot=F)$acf,
                              type='h',col='blue',ylab='',xlab='', cex.lab=cex, 
                              cex.lab=cex, cex.main=cex)
  
  # store the previous plotting settings:
  prevMfrow <- par('mfrow')
  
  # 
  if (!is.null(cols)){
    if (!(1 %in% cols)) cols <- c(1, cols)
    colPlot <- cols
    parNum <- length(cols) - 1
  }
  
  counter <- 1
  for(chain in chains){
    
    # set parNum, columns to plot and variable names:
    if(is.null(cols)){parNum <- dim(chain)[2]-1 ; colPlot <- 1:parNum}
    if (is.null(names)) names <- c("log Post", paste("var", 1:parNum))
    samps <-  dim(chain)[1]
    par(mfrow=c(parNum, 1))
    
    # plot trace:
    if (!is.null(filePath)) {
      pdf(paste(filePath, counter, ".PDF", sep=""), ...)
      par(mfrow=c(parNum, 1))
      counter <- counter + 1
    }
    
    apply(chain[,colPlot[-1]], 2, plotCol)
    if (!is.null(filePath)) dev.off()
    
    # plot ACF:
    if (!is.null(filePath)){
      try(pdf(paste(filePath, counter, ".PDF", sep=""), ...), silent = T)
      par(mfrow=c(parNum, 1))
      counter <- counter + 1
    }
    
    try(apply(chain[,colPlot[-1]], 2, plotACF), silent = T)
    if (!is.null(filePath)) dev.off()
    
    # plot joint posteriors:
    class(chain) <- "matrix"
    df <- data.frame(chain[runif(1000,1,nrow(chain)), colPlot])
    names(df) <- names
    
    if (!is.null(filePath)) {
      try(pdf(paste(filePath, counter, ".PDF", sep=""), ...), silent = T)
      par(mfrow=c(parNum, 1))
      counter <- counter + 1
    }
    
    plot(df, pch=16,col=adjustcolor('black', alpha=0.2), cex.lab=cex)
    if (!is.null(filePath)) dev.off()
  }
  
  # reset the graphical parameters to what they were before the call:
  par(mfrow=prevMfrow)
}

thinMCMC <- function(pMCMCoutput, alpha=0.1, removeBI=FALSE){
  # purpose : takes the output of the pHM function, and thins the chain to the
  #           desired level
  # inputs  : pMCMCMoutput - the output list of chains from the pMH function
  #           alpha        - the percentage of points to keep
  #           removeBI     - a number between 0 and 1 which indicates how far 
  #                          through the chain the burn in ends
  
  nchains <- length(pMCMCoutput)
  
  for (i in 1:nchains){
    chain <- pMCMCoutput[[i]]
    if (!is.null(removeBI)){
      pMCMCoutput[[i]] <- chain[round(nrow(chain)*removeBI):nrow(chain),]
    }
    
    n <- nrow(pMCMCoutput[[i]])
    toKeep <- round(seq(1,n,length=round(alpha*n)))
    pMCMCoutput[[i]] <- pMCMCoutput[[i]][toKeep,]
  }
  
  return(pMCMCoutput)
}

getAcceptance <- function(pMCMCoutput, start = 1, end = NULL){
  # purpose : Calculates each chain's acceptance probability
  # inputs  : pMCMCoutput - the output list of chains from the pMH function
  #           start       - the sample at which we start considering the
  #                         acceptance probability
  # output  : A numeric vector with the acceptance proability of each chain
  
  n <- length(pMCMCoutput)
  output <- rep(NA, n)
  
  for (i in 1:n){
    chain <- pMCMCoutput[[i]]
    N <- nrow(chain)
    if (is.null(end)) end <- N
    output[i] <- chain[start:end,1] %>% diff %>% `!=`(0) %>% sum %>% `/`(N)
  }
  
  return(output)
}

grDiagnostic <- function(chains){
  # purpose : Uses the CODA library to conduct a Gelman-Rubin test for MCMC
  #           convergence
  # inputs  : A list conatining the reult of the MCMC chains, assuming that
  #           the first column gives the value of the log-posterior
  # output  : Plot of the G-R convergence diagnostic test statistic
  require(coda)
  thinnednl <- lapply(chains, function(x) x[,-1])
  combined <- thinnednl %>% lapply(FUN=mcmc) %>% do.call(what=mcmc.list)
  gelman.plot(combined)
}
